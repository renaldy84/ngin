var sys = require('sys');

var debug;
var debugLevel = parseInt(process.env.NODE_DEBUG, 16);
if(debugLevel & 0x4) {
    debug = function (x) { sys.error('mredis: ' + x); };
} else {
    debug = function () { };
}

var net = require('net');
var events = require('events');
var Buffer = require('buffer').Buffer;

var FreeList = require('freelist').FreeList;

var parsers = new FreeList('parsers', 1000, function () {
    var parser = new Parser();

    parser.onCommandType = function (type) {
	parser.socket.onCommandType.apply(parser.socket, arguments);
    };
    parser.onMBulkLength = function () {
	parser.socket.onMBulkLength.apply(parser.socket, arguments);
    };
    parser.onBulkLength = function () {
	parser.socket.onBulkLength.apply(parser.socket, arguments);
    };
    parser.onData = function () {
	parser.socket.onData.apply(parser.socket, arguments);
    };
    parser.onDataEnd = function () {
	parser.socket.onDataEnd.apply(parser.socket, arguments);
    };
    parser.onMBulkEnd = function () {
	parser.socket.onMBulkEnd.apply(parser.socket, arguments);
    };

    return parser;
});

var sym = 0;
function Symbol (string) {
    this.sym = sym++;
    this.string = string;
}

Symbol.prototype.toString = function () {
    return this.string;
};

function Counter () {
    this.value = 0;
    this.negative = false;
};
exports.Counter = Counter;

Counter.prototype.base = 10;

Counter.prototype.read = function (c) {
    if (c >= 48 && c <= 57) { // >= '0' && <= '9'
	this.value *= this.base;
	this.value += (c - 48);
    } else if (c == 45) { // '-'
	this.negative = true;
    }
};

Counter.prototype.reinitialize = function () {
    Counter.call(this);
};

Counter.prototype.getValue = function () {
    return this.negative ? -1 : this.value;
};


function Parser () {
    this.commandType = null;
    this.parseState = this.parseState_command;
    this.parseError = null;

    this.commandStart = 0;

    this.onCommandType = null;
    this.onBulkLength = null;
    this.onData = null;
    this.onDataEnd = null;

    this._counter = new Counter();
    this.datalen = null;
    this.mbulklen = null;
}
exports.Parser = Parser;

Parser.prototype.commandType_error = 0;
Parser.prototype.commandType_singleline = 1;
Parser.prototype.commandType_bulk = 2;
Parser.prototype.commandType_mbulk = 3;
Parser.prototype.commandType_integer = 4;

Parser.prototype.parseState_command = 0;
Parser.prototype.parseState_mbulk = 1;
Parser.prototype.parseState_bulk = 2;
Parser.prototype.parseState_bulkdata = 3;
Parser.prototype.parseState_line = 4;
Parser.prototype.parseState_r = 5;
Parser.prototype.parseState_n = 6;

Parser.prototype.reinitialize = function () {
    this.commandType = null;
    this.parseState = this.parseState_command;
    this.parseError = null;

    this.commandStart = 0;

    this._counter.reinitialize();
    this.datalen = null;
    this.mbulklen = null;
};

Parser.prototype.parse = function (b, start, end) {
    if (this.parseError)
	return;
    var i = start, c = 0;
    if (start > end)
	throw new Error ("start should < end");
    if (end > b.length)
	throw new Error ("end extends beyond buffer");
    this.commandStart = i;
    for (i = start; i < end; i++) {
	if (this.datalen) {
	    --this.datalen;
	    continue;
	}
	c = b[i];
	switch(this.parseState) {
	case this.parseState_command:
	    switch (c) {
	    case 45: // -
		this.commandType = this.commandType_error;
		this.parseState = this.parseState_line;
		break;
	    case 43: // +
		this.commandType = this.commandType_singleline;
		this.parseState = this.parseState_line;
		break;
	    case 36: // $
		this.commandType = this.commandType_bulk;
		this.parseState = this.parseState_bulk;
		break;
	    case 42: // *
		this.commandType = this.commandType_mbulk;
		this.parseState = this.parseState_mbulk;
		break;
	    case 58: // :
		this.commandType = this.commandType_integer;
		this.parseState = this.parseState_line;
		break;
	    default:
		this.parseError = true;
		return;
	    }
	    this.onCommandType (this.commandType);
	    this.commandStart = i + 1;
	    break;
	case this.parseState_mbulk:
	case this.parseState_bulk:
	    if (c != 13) {
		this._counter.read(c);
	    } else {
		if (this.mbulklen > 0) {
		    --this.mbulklen;
		}
		this.parseState = this.parseState_n;
	    }
	    break;
	case this.parseState_bulkdata:
	    if (this.datalen == 0) {
		if (i > this.commandStart)
		    this.onData(b, this.commandStart, i);
		this.onDataEnd();
		this.parseState = this.parseState_n;

		if (this.mbulklen == 0) {
		    this.onMBulkEnd();
		    this.mbulklen = null;
		}
	    } else {
		--this.datalen;
	    }
	    break;
	case this.parseState_mbulk:
	    if (c != 13) {
		this._counter.read(c);
	    } else {
		this.parseState = this.parseState_n;
	    }
	    break;
	case this.parseState_line:
	    if (c == 13) { // \r
		if (i > this.commandStart)
		    this.onData (b, this.commandStart, i);
		this.onDataEnd();
		this.parseState = this.parseState_n;
	    }
	    break;
	case this.parseState_r:
	    if (c != 13) { // \r
		this.parseError = true;
		return;
	    }
	    this.parseState = this.parseState_n;
	    break;
	case this.parseState_n:
	    if (c != 10) { // \n
		this.parseError = true;
		return;
	    }
	    switch (this.commandType) {
	    case this.commandType_mbulk:
		this.mbulklen = this._counter.getValue();
		this.onMBulkLength(this.mbulklen);
		this._counter.reinitialize();

		if (this.mbulklen == 0) {
		    this.onMBulkEnd();
		    this.mbulklen = null;
		}

		this.parseState = this.parseState_command;
		break;
	    case this.commandType_bulk:
		if (this.datalen == null) {
		    this.datalen = this._counter.getValue();
		    this.onBulkLength(this.datalen);
		    this._counter.reinitialize();
		    this.commandStart = i + 1;

		    if (this.datalen == -1) {
			this.parseState = this.parseState_command;
			this.datalen = null;
		    } else {
			this.parseState = this.parseState_bulkdata;
		    }
		} else {
		    this.datalen = null;
		    this.parseState = this.parseState_command;
		}
		break;
	    case this.commandType_error:
	    case this.commandType_singleline:
	    case this.commandType_integer:
		this.parseState = this.parseState_command;
	    }
	    break;
	}
    }
    switch (this.parseState) {
    case this.parseState_command:
    case this.parseState_bulk:
	break;
    case this.parseState_bulkdata:
    case this.parseState_line:
	if (i > this.commandStart)
	    this.onData (b, this.commandStart, i);
	break;
    case this.parseState_mbulk:
    case this.parseState_r:
    case this.parseState_n:
	break;
    }
};

Parser.prototype.finish = function () {
    
};

function Client () {
    net.Stream.call(this);

    var parser;
    var self = this;

    this.output = [];
    this.outputEncodings = [];

    function initParser () {
	if (!parser) parser = parsers.alloc();
	parser.reinitialize();
	parser.socket = self;
    };

    this.ondata = function (d, start, end) {
	debug('this.ondata');
	parser.parse(d, start, end);
	if (parser.parseError instanceof Error) {
	    self.destroy(parser.parseError);
	}
    };

    this.on("connect", function () {
	debug('client connected');
	initParser();
	self._flush();
    });

    this.onend = function () {
	if (parser) parser.finish();
	debug("this got end closing. readyState = " + this.readyState);
	self.end();
    };

    this.on("close", function (e) {
	if (e) return;

	// If there are more requests to handle, reconnect.
	if (self.output.length) {
	    self._reconnect();
	} else if (parser) {
	    parsers.free(parser);
	    parser = null;
	}
    });
};
sys.inherits(Client, net.Stream);
exports.Client = Client;

Client.prototype._reconnect = function () {
    if (this.readyState === "closed") {
	this.connect(this.port, this.host);
    }
};

Client.prototype._buffer = function (data, encoding) {
    // Buffer
    if (data.length === 0) return;

    var length = this.output.length;

    if (length === 0 || typeof (data) != 'string') {
	this.output.push(data);
	encoding = encoding || "ascii";
	this.outputEncodings.push(encoding);
	return false;
    }

    var lastEncoding = this.outputEncodings[length-1];
    var lastData = this.output[length - 1];

    if ((lastEncoding === encoding) ||
	(!encoding && data.constructor === lastData.constructor)) {
	this.output[length-1] = lastData + data;
	return false;
    }

    this.output.push(data);
    encoding = encoding || "ascii";
    this.outputEncodings.push(encoding);

    return false;
};

Client.prototype._bufwrite = function (data, encoding) {
    if (typeof data !== "string"
	&& !Buffer.isBuffer(data)
	&& !Array.isArray(data)) {
	throw new TypeError("first argument must be a string, Array, or Buffer");
    }

    if (data.length === 0) return false;

    if (this.writable) {
	// There might be pending data in the this.output buffer
	while (this.output.length) {
	    if (!this.writable) {
		this._buffer(data, encoding);
		return false;
	    }
	    var c = this.output.shift();
	    var e = this.outputEncodings.shift();
	    this.write(c, e);
	}

	// Directly write to socket.
	return this.write(data, encoding);
    } else {
	this._buffer(data, encoding);
	return false;
    }

    return ret;
};

Client.prototype._flush = function () {
    var ret;
    while (this.output.length) {
	if (!this.writable) return;

	var data = this.output.shift();
	var encoding = this.outputEncodings.shift();

	ret = this._bufwrite(data, encoding);
    }
};

Client.prototype.query = function () {
    var query = "*" + arguments.length.toString() + "\r\n";
    for (var i = 0; i < arguments.length; i++) {
	var arg = arguments[i].toString();
	query += ("$" + Buffer.byteLength(arg, "utf8") + "\r\n" +
		  arg + "\r\n");
    }
    if (this.readyState === 'closed') this._reconnect();
    this._bufwrite(query);
};

exports.createClient = function (port, host) {
    var c = new Client();
    c.port = port;
    c.host = host;
    return c;
};

function BufferingClient () {
    Client.call(this);

    this.callbacks = [];

    this.line = "";
    this.bulk_buffer = new Buffer (16384);
    this.mbulk = [];

    this.buflen = 0;

    this.commandType = null;
    this.mbulklen = null;
    this.bulklen = null;
    this.bulkcount = null;
}
sys.inherits(BufferingClient, Client);

BufferingClient.prototype.nocallback = function () { };

BufferingClient.prototype.onCommandType = function (commandType) {
    debug('BufferingClient.onCommandType');
    this.commandType = commandType;
};

BufferingClient.prototype.onMBulkLength = function (len) {
    debug('BufferingClient.onMBulkLength');
    this.mbulklen = len;
};

BufferingClient.prototype.onBulkLength = function (len) {
    debug('BufferingClient.onBulkLength');
    this.bulklen = len;

    if (this.mbulklen || len > this.bulk_buffer.length) {
	this.bulk_buffer = new Buffer(len);
    }
    // todo: shrink buffer
};

BufferingClient.prototype.encoding = "utf8";

BufferingClient.prototype.setEncoding = function (encoding) {
    this.encoding = encoding;
};

BufferingClient.prototype.onData = function (b, start, end) {
    debug('BufferingClient.onData');
    if (this.commandType == 2) {
	// bulk data
	this.buflen += b.copy(this.bulk_buffer, this.buflen, start, end);
    } else if (this.commandType == 0 || this.commandType == 1 || this.commandType == 4) {
	// error, single line or integer
	this.line += b.toString(this.encoding, start, end);
    }
};

BufferingClient.prototype.onDataEnd = function () {
    debug('BufferingClient.onDataEnd');
    if (this.mbulklen) {
	this.mbulk.push(this.bulk_buffer.slice(0, this.buflen));
    } else {
	var callback = this.callbacks.shift();
	if (this.commandType == 2) {
	    // bulk data
	    callback (this.bulk_buffer.slice(0, this.buflen), false);
	} else if (this.commandType == 0 || this.commandType == 1) {
	    // error or single line
	    callback (this.line, this.commandType == 0);
	} else if (this.commandType == 4) {
	    // integer
	    callback (parseInt(this.line), false);
	}
    }
    this.line = "";
    this.buflen = 0;
    this.bulklen = null;
};

BufferingClient.prototype.onMBulkEnd = function () {
    debug('BufferingClient.onMBulkEnd');
    this.callbacks.shift() (this.mbulk, false);
    while (this.mbulk.length) this.mbulk.pop();
    this.mbulklen = null;
};

BufferingClient.prototype.query = function () {
    var args = new Array(arguments.length), callback = null;
    for (var i = 0; i < arguments.length; i++) {
	args[i] = arguments[i];
    }
    if (args.length && typeof (args[args.length-1]) === "function") {
	this.callbacks.push(args.pop());
    } else {
	this.callbacks.push(this.nocallback);
    }

    Client.prototype.query.apply(this, args);
};

exports.createBufferingClient = function (port, host) {
    var c = new BufferingClient();
    c.port = port;
    c.host = host;
    return c;
};

function ClientReadStream () {
}
sys.inherits(ClientReadStream, events.EventEmitter);
exports.ClientReadStream = ClientReadStream;

ClientReadStream.prototype.pause = function () {
    this.emit("pause");
};

ClientReadStream.prototype.resume = function () {
    this.emit("resume");
};

function ClientWriteStream (client, args) {
    this.client = client;
    this.args = args;
    this.writable = true;
}
sys.inherits(ClientWriteStream, events.EventEmitter);
exports.ClientWriteStream = ClientWriteStream;

ClientWriteStream.prototype.write = function (chunk) {
    debug('ClientWriteStream.write');
    this.args[this.args.length - 1] = chunk;
    this.client.query.apply(this.client, this.args);
};

ClientWriteStream.prototype.end = function () {
    if (arguments.length) this.write.apply(this, arguments);
};

ClientWriteStream.prototype.destroy = function () {
    debug('ClientWriteStream.destroy');
    for (var i = 0; i < this.client._outgoing.length; i++) {
	if (this.client._outgoing[i] === this) {
	    this.client._outgoing.splice(i, 1);
	    break;
	}
    }
};

ClientWriteStream.prototype.pause = function () {
    this.emit("pause");
};

ClientWriteStream.prototype.resume = function () {
    this.emit("resume");
};

function callOutgoing (key) {
    return function () {
	for (var i = 0; i < this._outgoing.length; i++) {
	    if (this._outgoing[i]) this._outgoing[i][key] ();
	}
    };
}

function StreamingClient () {
    Client.call(this);

    this._incoming = [];
    this._outgoing = [];

    this.commandType = null;
    this.mbulklen = null;
    this.bulklen = null;
    this.bulkcount = null;

    this.on("pause", this._pauseOutgoing);
    this.on("drain", this._drainOutgoing);
    this.on("resume", this._resumeOutgoing);
    this.on("end", this._endOutgoing);
    this.on("close", this._closeOutgoing);
    this.on("error", debug);
}
sys.inherits(StreamingClient, Client);

StreamingClient.prototype._pauseOutgoing = callOutgoing('pause');

StreamingClient.prototype._drainOutgoing = function () {
    for (var i = 0; i < this._outgoing.length; i++) {
	if (this._outgoing[i]) this._outgoing[i].emit("drain");
    }
};

StreamingClient.prototype._resumeOutgoing = callOutgoing('resume');

StreamingClient.prototype._endOutgoing = callOutgoing('end');

StreamingClient.prototype._closeOutgoing = callOutgoing('close');

StreamingClient.prototype.onCommandType = function (commandType) {
    debug('StreamingClient.onCommandType');
    this.commandType = commandType;
};

StreamingClient.prototype.onMBulkLength = function (len) {
    debug('StreamingClient.onMBulkLength');
    this.mbulklen = len;
};

StreamingClient.prototype.onBulkLength = function (len) {
    debug('StreamingClient.onBulkLength');
    this.bulkcount = 0;
    this.bulklen = len;
};

StreamingClient.prototype.onData = function (b, start, end) {
    debug('StreamingClient.onData');
    if (this._incoming[0]) {
	this._incoming[0].emit("data", b.slice(start, end));
    }
};

StreamingClient.prototype.onDataEnd = function () {
    debug('StreamingClient.onDataEnd');
    if (!this.mbulklen) {
	if (this._incoming[0]) {
	    this._incoming[0].emit("end");
	}
	this._incoming.shift();
    }
    this.bulklen = null;
};

StreamingClient.prototype.onMBulkEnd = function () {
    debug('StreamingClient.onMBulkEnd');
    if (this._incoming[0]) {
	this._incoming[0].emit("end");
    }
    this._outgoing.shift();
    this.mbulklen = null;
};

StreamingClient.prototype.query = function () {
    this._incoming.push(null);
    Client.prototype.query.apply(this, arguments);
};

StreamingClient.prototype.createReadStream = function () {
    var stream = new ClientReadStream();
    this._incoming.push(stream);
    this.query.apply(this, arguments);
    return stream;
};

StreamingClient.prototype.createWriteStream = function () {
    if (arguments.length < 2) {
	throw new Error ();
    }
    var args = new Array(arguments.length + 1);
    for (var i = 0; i < arguments.length; i++) {
	args[i] = arguments[i];
    }
    var stream = new ClientWriteStream(this, args);
    this._outgoing.push(stream);
    return stream;
};

exports.createStreamingClient = function (port, host) {
    var c = new StreamingClient();
    c.port = port;
    c.host = host;
    return c;
};
