var sys = require('sys');

var debug;
var debugLevel = parseInt(process.env.NODE_DEBUG, 16);
if(debugLevel & 0x4) {
    debug = function (x) { sys.error('nredis: ' + x); };
} else {
    debug = function () { };
}

var net = require('net');
var events = require('events');
var Buffer = require('buffer').Buffer;

var FreeList = require('freelist').FreeList;

var parsers = new FreeList('parsers', 1000, function () {
    var parser = new Parser();
    var type, nbulk, mbulklen, datalen;

    parser.onCommandType = function (commandType) {
	debug('parser.onCommandType');
	switch (commandType) {
	case parser.commandType_error:
	    debug("type: error");
	    break;
	case parser.commandType_singleline:
	    debug("type: single line");
	    break;
	case parser.commandType_bulk:
	    debug("type: bulk");
	    break;
	case parser.commandType_mbulk:
	    debug("type: mbulk");
	    break;
	case parser.commandType_integer:
	    debug("type: integer");
	    break;
	}
	type = commandType;
    };
    parser.onMBulkLength = function (len) {
	debug('parser.onMBulkLength');
	debug('len: ' + len);
	mbulklen = len;
	nbulk = 0;
    };
    parser.onBulkLength = function (len) {
	debug('parser.onBulkLength');
	debug('len: ' + len);
	datalen = len;
    };
    parser.onData = function (b, start, end) {
	debug('parser.onData');
	parser.socket._outgoing[0].emit("data", type, b, start, end, datalen, nbulk, mbulklen);
    };
    parser.onDataEnd = function () {
	debug('parser.onDataEnd');
	if (mbulklen && nbulk < mbulklen)
	    ++nbulk;
    };
    parser.onMBulkEnd = function () {
	debug('parser.onMBulkEnd');
    };

    return parser;
});

var sym = 0;
function gensym () {
    return sym++;
};

function Counter () {
    this.value = 0;
    this.negative = false;
};
exports.Counter = Counter;

Counter.prototype.base = 10;

Counter.prototype.read = function (c) {
    if (c >= 48 && c <= 57) { // >= '0' && <= '9'
	this.value *= this.base;
	this.value += (c - 48);
    } else if (c == 45) { // '-'
	this.negative = true;
    }
};

Counter.prototype.reinitialize = function () {
    Counter.call(this);
};

Counter.prototype.getValue = function () {
    return this.negative ? -1 : this.value;
};

function Parser () {
    this.commandType = null;
    this.parseState = this.parseState_command;
    this.parseError = null;

    this.commandStart = 0;

    this.onCommandType = null;
    this.onBulkLength = null;
    this.onData = null;
    this.onDataEnd = null;

    this._counter = new Counter();
    this.datalen = null;
    this.mbulklen = null;
}
exports.Parser = Parser;

Parser.prototype.commandType_error = gensym();
Parser.prototype.commandType_singleline = gensym();
Parser.prototype.commandType_bulk = gensym();
Parser.prototype.commandType_mbulk = gensym();
Parser.prototype.commandType_integer = gensym();

Parser.prototype.parseState_command = gensym();
Parser.prototype.parseState_bulk = gensym();
Parser.prototype.parseState_bulkdata = gensym();
Parser.prototype.parseState_mbulk = gensym();
Parser.prototype.parseState_line = gensym();
Parser.prototype.parseState_r = gensym();
Parser.prototype.parseState_n = gensym();

Parser.prototype.reinitialize = function () {
    this.commandType = null;
    this.parseState = this.parseState_command;
    this.parseError = null;

    this.commandStart = 0;

    this._counter.reinitialize();
    this.datalen = null;
    this.mbulklen = null;
};

Parser.prototype.parse = function (b, start, end) {
    if (this.parseError)
	return;
    var i = start, c = 0;
    if (start > end)
	throw new Error ("start should < end");
    if (end > b.length)
	throw new Error ("end extends beyond buffer");
    this.commandStart = i;
    for (i = start; i < end; i++) {
	c = b[i];
	switch(this.parseState) {
	case this.parseState_command:
	    switch (c) {
	    case 45: // -
		this.commandType = this.messageType_error;
		this.parseState = this.parseState_line;
		break;
	    case 43: // +
		this.commandType = this.commandType_singleline;
		this.parseState = this.parseState_line;
		break;
	    case 36: // $
		this.commandType = this.commandType_bulk;
		this.parseState = this.parseState_bulk;
		break;
	    case 42: // *
		this.commandType = this.commandType_mbulk;
		this.parseState = this.parseState_mbulk;
		break;
	    case 58: // :
		this.commandType = this.commandType_integer;
		this.parseState = this.parseState_line;
		break;
	    default:
		this.parseError = true;
		return;
	    }
	    this.onCommandType (this.commandType);
	    this.commandStart = i + 1;
	    break;
	case this.parseState_mbulk:
	case this.parseState_bulk:
	    if (c != 13) {
		this._counter.read(c);
	    } else {
		if (this.mbulklen > 0) {
		    --this.mbulklen;
		}
		this.parseState = this.parseState_n;
	    }
	    break;
	case this.parseState_bulkdata:
	    if (this.datalen == 0) {
		if (i > this.commandStart)
		    this.onData(b, this.commandStart, i);
		this.onDataEnd();
		this.parseState = this.parseState_n;

		if (this.mbulklen == 0) {
		    this.onMBulkEnd();
		    this.mbulklen = null;
		}
	    } else {
		--this.datalen;
	    }
	    break;
	case this.parseState_mbulk:
	    if (c != 13) {
		this._counter.read(c);
	    } else {
		this.parseState = this.parseState_n;
	    }
	    break;
	case this.parseState_line:
	    if (c == 13) { // \r
		if (i > this.commandStart)
		    this.onData (b, this.commandStart, i);
		this.onDataEnd();
		this.parseState = this.parseState_n;
	    }
	    break;
	case this.parseState_r:
	    if (c != 13) { // \r
		this.parseError = true;
		return;
	    }
	    this.parseState = this.parseState_n;
	    break;
	case this.parseState_n:
	    if (c != 10) { // \n
		this.parseError = true;
		return;
	    }
	    switch (this.commandType) {
	    case this.commandType_mbulk:
		this.mbulklen = this._counter.getValue();
		this.onMBulkLength(this.mbulklen);
		this._counter.reinitialize();

		this.parseState = this.parseState_command;
		break;
	    case this.commandType_bulk:
		if (this.datalen == null) {
		    this.datalen = this._counter.getValue();
		    this.onBulkLength(this.datalen);
		    this._counter.reinitialize();
		    this.commandStart = i + 1;

		    this.parseState = this.parseState_bulkdata;
		} else {
		    this.datalen = null;
		    this.parseState = this.parseState_command;
		}
		break;
	    case this.commandType_error:
	    case this.commandType_singleline:
	    case this.commandType_integer:
		this.parseState = this.parseState_command;
	    }
	    break;
	}
    }
    switch (this.parseState) {
    case this.parseState_command:
    case this.parseState_bulk:
	break;
    case this.parseState_bulkdata:
    case this.parseState_line:
	if (i > this.commandStart)
	    this.onData (b, this.commandStart, i);
	break;
    case this.parseState_mbulk:
    case this.parseState_r:
    case this.parseState_n:
	break;
    }
};

function OutgoingMessage (socket) {
    events.EventEmitter.call(this, socket);

    this.socket = socket;

    this.output = [];
    this.outputEncodings = [];

    this._last = false;

    this.finished = false;
}
sys.inherits(OutgoingMessage, events.EventEmitter);
exports.OutgoingMessage = OutgoingMessage;

OutgoingMessage.prototype._send = function (data, encoding) {
    if (this.socket._outgoing[0] === this && this.socket.writeable) {
	// There might be pending data in the this.output buffer
	while (this.output.length) {
	    if (!this.socket.writeable) {
		this._buffer(data, encoding);
		return false;
	    }
	    var c = this.output.shift();
	    var e = this.outputEncodings.shift();
	    this.socket.write(c, e);
	}

	// Directly write to socket.
	return this.socket.write(data, encoding)
    } else {
	this._buffer(data, encoding);
	return false;
    }
};

OutgoingMessage.prototype._buffer = function (data, encoding) {
    // Buffer
    if (data.length === 0) return;

    var length = this.output.length;

    if (length === 0 || typeof (data) != 'string') {
	this.output.push(data);
	encoding = encoding || "ascii";
	this.outputEncodings.push(encoding);
	return false;
    }

    var lastEncoding = this.outputEncodings[length-1];
    var lastData = this.output[length - 1];

    if ((lastEncoding === encoding) ||
	(!encoding && data.constructor === lastData.constructor)) {
	this.output[length-1] = lastData + data;
	return false;
    }

    this.output.push(data);
    encoding = encoding || "ascii";
    this.outputEncodings.push(encoding);

    return false;
};

OutgoingMessage.prototype.write = function (chunk, encoding) {
    if (typeof chunk !== "string"
	&& !Buffer.isBuffer(chunk)
	&& !Array.isArray(chunk)) {
	throw new TypeError("first argument must be a string, Array, or Buffer");
    }

    if (chunk.length === 0) return false;

    var len, ret;
    ret = this._send(chunk, encoding);

    debug('write ret = ' + ret);
    return ret;
};

var closeWarning;

OutgoingMessage.prototype.end = function (data, encoding) {
    var ret;

    if (data) {
	ret = this.write(data, encoding);
    }

    this.finished = true;

    if (this.output.length === 0 && this.socket._outgoing[0] === this) {
	debug('outgoing message end. shifting because was flushed');
	this.socket._onOutgoingSent();
    }

    return ret;
};

OutgoingMessage.prototype._storeHeader = function (firstArg, args) {
    if (typeof arg !== "string"
	&& !Buffer.isBuffer(arg)
	&& !Array.isArray(arg)) {
	throw new TypeError("first argument must be a string, Array, or Buffer");
    }

    if (arg.length === 0) return false;
};

function ClientRequest (socket, data, encoding, requestListener) {
    OutgoingMessage.call(this, socket);
    this.nrealloc = 1;
    this.off = 0;
    this.buf = null;
    if (requestListener) {
	this.on("request", requestListener);
	this.on("data", dataListener);
    }
    this.write(data, encoding);
};
sys.inherits(ClientRequest, OutgoingMessage);
exports.ClientRequest = ClientRequest;

function dataListener(type, buf, start, end, len, nbulk, mbulklen) {
    var buflen = end - start;
    var tmp;
    if (this.buf == null) {
	debug('this.buf = new Buffer(buflen);');
	this.buf = new Buffer(buflen);
    } else if (this.buf.length < this.off + buflen) {
	while (this.nrealloc < this.off + buflen)
	    this.nrealloc *= 2;
	tmp = new Buffer(this.nrealloc);
	this.buf.copy(tmp, 0, 0, this.off);
	debug('this.buf = tmp;');
	this.buf = tmp;
    }
    buf.copy(this.buf, this.off, start, end);
    this.off += buflen;
    if (this.off == len) {
	this.emit("request", type, this.buf, 0, this.off);
    }
}

function outgoingFlush (socket) {
    var message = socket._outgoing[0];

    if (!message) return;

    var ret;

    while (message.output.length) {
	var data = message.output.shift();
	var encoding = message.outputEncodings.shift();

	ret = socket.write(data, encoding);
    }

    if (message.finished) {
	socket._onOutgoingSent();
    } else if (ret) {
	message.emit('drain');
    }
};

function Client () {
    net.Stream.call(this);
    var self = this;

    var parser;

    function initParser () {
	if (!parser) parser = parsers.alloc();
	parser.reinitialize();
	parser.socket = self;
	parser.onIncoming = function () {
	    debug("incoming response!");
	};
	parser.onCommandEnd = function (res) {
	    debug("parser.onCommandEnd");
	    self._outgoing.shift();
	};
    };

    self.ondata = function (d, start, end) {
	debug('self.ondata');
	var ret = parser.parse(d, start, end);
	if (parser.parseError) {
	    self.destroy(ret);
	} else {
	    
	}
    };

    this.on("connect", function () {
	debug('client connected');
	initParser();
	debug('request: ' + sys.inspect(self._outgoing));
	outgoingFlush(self);
    });

    self.onend = function () {
	if (parser) parser.finish();
	debug("self got end closing. readyState = " + self.readyState);
	self.end();
    };

    this.on("close", function (e) {
	if (e) return;

	// If there are more requests to handle, reconnect.
	if (self._outgoing.length) {
	    self._reconnect();
	} else if (parser) {
	    parsers.free(parser);
	    parser = null;
	}
    });

    this._outgoing = [];
};
sys.inherits(Client, net.Stream);
exports.Client = Client;

var commands = ["get", "set"];
commands.forEach(function(commandName) {
    Client.prototype[commandName] = function () {
	var args = Array.prototype.slice(arguments);
	this.sendCommand.apply(this, args);
    };
});

Client.prototype._reconnect = function () {
    if (this.readyState === "closed") {
	this.connect(this.port, this.host);
    }
};

Client.prototype.queryEncoding = "utf8";

Client.prototype.bufSize = 8192;

Client.prototype.setBufSize = function (bufSize) {
    this.bufSize = bufSize;
};

Client.prototype.request = function () {
    var nargs = arguments.length;
    var requestListener = null;
    
    if (typeof arguments[nargs-1] === "function")
	requestListener = arguments[--nargs];

    var query = "*" + nargs.toString() + "\r\n";
    for (var i = 0; i < nargs; i++) {
	var arg = arguments[i].toString();
	query += ("$" + Buffer.byteLength(arg, this.queryEncoding) + "\r\n" +
		  arg + "\r\n");
    }

    var req = new ClientRequest(this, query, this.queryEncoding, requestListener);
    this._outgoing.push(req);
    if (this.readyState === "closed") this._reconnect();
    return req;
};

exports.createClient = function (port, host) {
    var c = new Client();
    c.port = port;
    c.host = host;
    return c;
};
