var ndns = require('../lib/ndns');
var sys = require('sys');
var net = require('net');
var events = require('events');

var debug;
var debugLevel = parseInt(process.env.NODE_DEBUG, 16);
if (debugLevel & 0x4) {
  debug = function (x) { sys.error('TUN: ' + x); };
} else {
  debug = function () { };
}

var TTL_CONNECT	 =	1;
var TTL_RECV	 = 	2;
var TTL_SEND	 = 	3;
var TTL_CLOSE	 = 	4;
var TTL_EPOLL	 = 	5;

function ClientStream(client) {
    this.client = client;
    this.fd = null;
    this.readyState = "";
};
sys.inherits(ClientStream, events.EventEmitter);

ClientStream.prototype.write = function (data, encoding) {
    if (!(typeof data === "string") &&
	!Buffer.isBuffer(data) &&
	!Array.isArray(data)) {
	throw new Error("Argument should be string, buffer or array");
    }
    if (typeof data === "string") {
	data = new Buffer(data);
    }
    var sent = 0;
    while (sent < data.length) {
	if (data.length - sent < 200) {
	    this.client.send(this.fd, data.slice(sent, data.length));
	    sent = data.length;
	} else {
	    this.client.send(this.fd, data.slice(sent, sent + 200));
	    sent += 200;
	}
    }
	
};

ClientStream.prototype.pause = function () {
    
};

ClientStream.prototype.resume = function () {
    
};

ClientStream.prototype.end = function () {
    this.emit("end");
    this.client.close(this.fd);
};

ClientStream.prototype.destroy = function () {
    this.client.close(this.fd);
};

function Client (clientName, clientPort, clientHost) {
    var self = this;

    this.clientPort = clientPort;
    this.clientHost = clientHost;
    this.clientName = clientName;
    this.client = ndns.createClient();
    this.client.on("response", function (res) {
	debug('response');
	
	var b, fd, ret;
	if (res.rr.length) {
	    b = res.rr[0].rdata[0];
	    debug(sys.inspect(b));
	    if (b.length < 8) return;
	    fd = ((b[0] << 24) + (b[1] << 16) + (b[2] << 8) + (b[3] << 0));
	    ret = ((b[4] << 24) + (b[5] << 16) + (b[6] << 8) + (b[7] << 0));
	    /*
	    debug('ret: ' + ret);
	    debug('fd: ' + fd);
	    debug('ttl: ' + res.rr[0].ttl);
	    */
	    switch (res.rr[0].ttl) {
	    case TTL_CONNECT:
		break;
	    case TTL_EPOLL:
	    case TTL_RECV:
		if (!self._connections[fd]) break;
		if (ret > 0) {
		    self._connections[fd].emit("data", b.slice(8, b.length));
		} else {
		    debug('end connection');
		    self._connections[fd].end();
		}
		self.poll();
		break;
	    case TTL_SEND:
		break;
	    case TTL_CLOSE:
		if (!self._connections[fd]) break;
		self._connections[fd].emit("close");
		break;
	    }
	}
    });

    this.req = this.client.request(this.clientPort, this.clientHost);
    this.req.addQuestion(".", ndns.ns_t.txt);
    this.req.addRR(".", 0, ndns.ns_t.txt, "");

    this.next = 0;
    this._connections = {};
};

Client.prototype.nextId = function () {
    //return ++this.next;
    return Math.floor(Math.random() * 65535);
};

Client.prototype.nextName = function () {
    //return ++this.next + "." + this.clientName;
    return Math.random() + "." + this.clientName;
};

Client.prototype.buf = new Buffer(65535);

function setupRequest (client, req, command, buf) {
    var nextName = client.nextName();
    req.header.id = client.nextId();
    req.header.qdcount = 1;
    req.header.arcount = 1;
    req.header.rd = 1;
    if (req.q.length) {
	req.q[0].name = nextName;
	req.q[0].class = ndns.ns_c.in;
	req.q[0].type = ndns.ns_t.txt;
    } else {
	req.addQuestion(nextName, ndns.ns_t.txt, buf)
    }
    if (req.rr.length) {
	req.rr[0].name = nextName;
	req.rr[0].ttl = command;
	req.rr[0].class = ndns.ns_c.in;
	req.rr[0].type = ndns.ns_t.txt;
	req.rr[0].rdata[0] = buf;
    } else {
	req.addRR(nextName, command, ndns.ns_t.txt, buf);
    }
}

Client.prototype.sendCommand = function (command, buf) {
    setupRequest(this, this.req, command, buf);
    this.req.send();
};

Client.prototype.connectStream = function (stream, port, host) {
    var self = this;
    var tmp;
    if ((tmp = host.split(".")).length !== 4) throw new Error("Invalid host");
    var req = this.client.request(this.clientPort, this.clientHost);
    self.buf[0] = tmp[0];
    self.buf[1] = tmp[1];
    self.buf[2] = tmp[2];
    self.buf[3] = tmp[3];
    self.buf[4] = (parseInt(port) >> 8) & 0xff;
    self.buf[5] = (parseInt(port) >> 0) & 0xff;
    setupRequest(self, req, TTL_CONNECT, self.buf.slice(0, 8));
    req.send();
    req.on("response", function (res) {
	debug('connect response');
	if (res.rr.length) {
	    b = res.rr[0].rdata[0];
	    if (b.length < 8) return;
	    var fd = ((b[0] << 24) + (b[1] << 16) + (b[2] << 8) + (b[3] << 0));
	    var ret = ((b[4] << 24) + (b[5] << 16) + (b[6] << 8) + (b[7] << 0));
	    if (ret == 0) {
		self._connections[fd] = stream;
		self._connections[fd].fd = fd;
		self._connections[fd].emit("connect");
	    }
	}
    });
    setInterval(function () { self.poll() }, 1000);
};

Client.prototype.recv = function (fd) {
    this.buf[0] = (fd >> 24) & 0xff;
    this.buf[1] = (fd >> 16) & 0xff;
    this.buf[2] = (fd >> 8) & 0xff;
    this.buf[3] = (fd >> 0) & 0xff;
    this.sendCommand(TTL_RECV, this.buf.slice(0, 8));
};

Client.prototype.send = function (fd, data) {
    this.buf[0] = (fd >> 24) & 0xff;
    this.buf[1] = (fd >> 16) & 0xff;
    this.buf[2] = (fd >> 8) & 0xff;
    this.buf[3] = (fd >> 0) & 0xff;
    if (data.length < this.buf.length - 8) {
	data.copy(this.buf, 8, 0, data.length);
	this.sendCommand(TTL_SEND, this.buf.slice (0, 8 + data.length));
    }
};
    
Client.prototype.close = function (fd) {
    this.buf[0] = (fd >> 24) & 0xff;
    this.buf[1] = (fd >> 16) & 0xff;
    this.buf[2] = (fd >> 8) & 0xff;
    this.buf[3] = (fd >> 0) & 0xff;
    this.sendCommand(TTL_CLOSE, this.buf.slice (0, 8));
};

Client.prototype.poll = function () {
    debug('Client.prototype.poll');
    this.buf[0] = this.buf[1] = this.buf[2] = this.buf[3] = 0;
    this.sendCommand(TTL_EPOLL, this.buf.slice(0, 8));
};

Client.prototype.createConnection = function (port, host) {
    var stream = new ClientStream (this);
    this.connectStream(stream, port, host);
    return stream;
};

//var client = new Client("abc.ttlcc.ignorelist.com", "53", "130.244.127.161");
//var client = new Client("abc.ttlcc.ignorelist.com", "53", "192.168.249.20");
//var client = new Client("abc.ttlcc.ignorelist.com", "1993", "127.0.0.1");
//var client = new Client("abc.ttlcc.ignorelist.com", "53", "130.244.127.161");
var client = new Client("a.ttlcc.ignorelist.com", "53", "192.168.249.20");
net.createServer(function (stream) {
    var cstream = client.createConnection("6667", "174.143.119.91");
    //var cstream = client.createConnection("22", "127.0.0.1");
    sys.pump(stream, cstream);
    sys.pump(cstream, stream);
}).listen(6668);
